# ADR-0017: C API for System Integration

## Status

Accepted

## Date

2024-07

## Context

While Rust is excellent for new projects, the video processing ecosystem includes:

1. **Legacy C/C++ applications** that need codec functionality
2. **Other languages** (Go, Python via ctypes, C#, Java via JNI) that can call C APIs
3. **Embedded systems** with C toolchains
4. **Plugin architectures** expecting C ABI compatibility

Transcode's Rust API cannot be directly consumed by these use cases. A stable C API enables:
- Integration with existing media frameworks
- Language bindings beyond Rust
- Deployment in C-first environments

## Decision

Implement a **C-compatible API** in `transcode-capi` that:

### 1. Uses C ABI Conventions

```rust
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TranscodeError {
    Success = 0,
    InvalidArgument = -1,
    NullPointer = -2,
    EndOfStream = -3,
    IoError = -4,
    CodecError = -5,
    // ... negative values for errors
}

#[no_mangle]
pub extern "C" fn transcode_open_input(
    path: *const c_char,
    ctx: *mut *mut TranscodeContext,
) -> TranscodeError {
    // Implementation
}
```

### 2. Follows FFmpeg-like Patterns

```c
// C usage pattern (familiar to FFmpeg users)
TranscodeContext* ctx = NULL;
TranscodeError err = transcode_open_input("input.mp4", &ctx);
if (err != TRANSCODE_ERROR_SUCCESS) {
    return 1;
}

TranscodePacket* packet = transcode_packet_alloc();
while (transcode_read_packet(ctx, packet) == TRANSCODE_ERROR_SUCCESS) {
    // Process packet
}

transcode_packet_free(packet);
transcode_close(ctx);
```

### 3. Enforces Safety Limits

```rust
/// Maximum packet size to prevent DoS (1 GB)
const MAX_PACKET_SIZE: usize = 1024 * 1024 * 1024;

/// Maximum path length (4 KB)
const MAX_PATH_LENGTH: usize = 4096;

/// Maximum frame dimension (16K)
const MAX_FRAME_DIMENSION: u32 = 16384;
```

### 4. Provides Opaque Handles

```rust
/// Opaque context handle
pub struct TranscodeContext {
    inner: Box<InternalContext>,
}

/// Opaque packet handle
pub struct TranscodePacket {
    inner: Packet<'static>,
}

/// Opaque frame handle
pub struct TranscodeFrame {
    inner: Frame,
}
```

### 5. Generates C Header

```c
// transcode.h (auto-generated)
#ifndef TRANSCODE_H
#define TRANSCODE_H

#include <stdint.h>
#include <stddef.h>

typedef struct TranscodeContext TranscodeContext;
typedef struct TranscodePacket TranscodePacket;
typedef struct TranscodeFrame TranscodeFrame;

typedef enum {
    TRANSCODE_ERROR_SUCCESS = 0,
    TRANSCODE_ERROR_INVALID_ARGUMENT = -1,
    // ...
} TranscodeError;

TranscodeError transcode_open_input(const char* path, TranscodeContext** ctx);
TranscodeError transcode_read_packet(TranscodeContext* ctx, TranscodePacket* packet);
void transcode_close(TranscodeContext* ctx);

TranscodePacket* transcode_packet_alloc(void);
void transcode_packet_free(TranscodePacket* packet);

// ...
#endif
```

## Consequences

### Positive

1. **Universal integration**: Any language with C FFI can use Transcode

2. **Familiar patterns**: FFmpeg users recognize the API style

3. **Stable ABI**: C ABI doesn't change; safe for dynamic linking

4. **No Rust requirement**: Consumers don't need Rust toolchain

5. **Safety preserved**: Rust safety guarantees still apply internally

### Negative

1. **Verbose**: C API is more verbose than idiomatic Rust

2. **Manual memory management**: Callers must free allocated resources

3. **Limited generics**: Can't expose Rust's type-safe abstractions

4. **Maintenance burden**: Must keep C and Rust APIs in sync

### Mitigations

1. **Comprehensive documentation**: Document ownership rules clearly

2. **Validation**: All inputs validated; null pointers return errors

3. **Resource tracking**: Debug builds can track leaked allocations

4. **Binding generators**: Use cbindgen for header generation

## Implementation Details

### Null Pointer Handling

```rust
#[no_mangle]
pub extern "C" fn transcode_open_input(
    path: *const c_char,
    ctx: *mut *mut TranscodeContext,
) -> TranscodeError {
    // Validate pointers
    if path.is_null() || ctx.is_null() {
        return TranscodeError::NullPointer;
    }

    // Safe string conversion
    let path_str = match unsafe { CStr::from_ptr(path) }.to_str() {
        Ok(s) => s,
        Err(_) => return TranscodeError::InvalidArgument,
    };

    // Validate path length
    if path_str.len() > MAX_PATH_LENGTH {
        return TranscodeError::InvalidArgument;
    }

    // Actual implementation...
}
```

### Resource Lifecycle

```rust
// Allocation
#[no_mangle]
pub extern "C" fn transcode_packet_alloc() -> *mut TranscodePacket {
    Box::into_raw(Box::new(TranscodePacket::default()))
}

// Deallocation
#[no_mangle]
pub extern "C" fn transcode_packet_free(packet: *mut TranscodePacket) {
    if !packet.is_null() {
        unsafe {
            drop(Box::from_raw(packet));
        }
    }
}
```

### Error Information

```rust
/// Thread-local error message storage
thread_local! {
    static LAST_ERROR: RefCell<String> = RefCell::new(String::new());
}

#[no_mangle]
pub extern "C" fn transcode_get_error_message() -> *const c_char {
    LAST_ERROR.with(|e| {
        let msg = e.borrow();
        msg.as_ptr() as *const c_char
    })
}

fn set_error(msg: String) {
    LAST_ERROR.with(|e| {
        *e.borrow_mut() = msg;
    });
}
```

### Stream Information

```rust
#[repr(C)]
pub struct TranscodeStreamInfo {
    pub index: u32,
    pub codec_type: TranscodeMediaType,
    pub codec_id: TranscodeCodecId,
    pub width: u32,        // Video only
    pub height: u32,       // Video only
    pub sample_rate: u32,  // Audio only
    pub channels: u32,     // Audio only
    pub duration_us: i64,
    pub bitrate: u64,
}

#[no_mangle]
pub extern "C" fn transcode_get_stream_info(
    ctx: *const TranscodeContext,
    index: u32,
    info: *mut TranscodeStreamInfo,
) -> TranscodeError {
    // Validate and copy stream info
}
```

## API Surface

### Context Management

| Function | Description |
|----------|-------------|
| `transcode_open_input` | Open input file/URL |
| `transcode_open_output` | Create output file |
| `transcode_close` | Close and free context |
| `transcode_get_stream_count` | Get number of streams |
| `transcode_get_stream_info` | Get stream metadata |

### Packet Operations

| Function | Description |
|----------|-------------|
| `transcode_packet_alloc` | Allocate packet |
| `transcode_packet_free` | Free packet |
| `transcode_read_packet` | Demux next packet |
| `transcode_write_packet` | Mux packet to output |
| `transcode_packet_get_data` | Get packet payload |
| `transcode_packet_get_pts` | Get presentation timestamp |

### Codec Operations

| Function | Description |
|----------|-------------|
| `transcode_decoder_create` | Create decoder |
| `transcode_decoder_decode` | Decode packet to frame |
| `transcode_encoder_create` | Create encoder |
| `transcode_encoder_encode` | Encode frame to packet |

### Frame Operations

| Function | Description |
|----------|-------------|
| `transcode_frame_alloc` | Allocate frame |
| `transcode_frame_free` | Free frame |
| `transcode_frame_get_plane` | Get plane data pointer |
| `transcode_frame_get_width` | Get frame width |
| `transcode_frame_get_height` | Get frame height |

## Alternatives Considered

### Alternative 1: SWIG Bindings

Use SWIG to generate bindings automatically.

Rejected because:
- SWIG doesn't understand Rust
- Generated code is hard to maintain
- Limited control over API design

### Alternative 2: Protocol Buffers / gRPC

Expose functionality via IPC.

Rejected because:
- High overhead for codec operations
- Doesn't fit in-process use case
- Complex deployment

### Alternative 3: Minimal C API

Only expose high-level transcoding function.

Rejected because:
- Insufficient for advanced use cases
- Can't integrate with existing pipelines
- Limited flexibility

## Security Considerations

1. **Input validation**: All string inputs checked for length and encoding

2. **Bounds checking**: Array accesses validated before dereferencing

3. **Integer overflow**: Size calculations checked for overflow

4. **Resource limits**: Maximum allocations enforced

5. **No undefined behavior**: All unsafe blocks carefully audited

## References

- [Rust FFI Guide](https://doc.rust-lang.org/nomicon/ffi.html)
- [cbindgen](https://github.com/eqrion/cbindgen)
- [FFmpeg libavcodec API](https://ffmpeg.org/doxygen/trunk/group__lavc__decoding.html)
- [Safer C API Design](https://www.tedunangst.com/flak/post/safe-C-programming-API-design)
